1500시간

자체적으로 계속 공부해야

하루 4시간 이상 

---------------------기본 문법

1. Java란

James Gosling  1995 Object Oriented Programming

객체지향
캡슐화
상속
다형성
GAbage collection
플랫폼 독립

자동으로 오픈

2. Java 파일의 컴파일 순서

두번의 컴파일이 일어남

java->class->기계어 



모든 프로그램은 class로 시작

항상 시작(진입점)은 main 함수로 시작 - 그 안에 다른 함수를 불러서 사용

 //이미 정해해져 있는 함수는 그 함수가 속한 클래스도 같이 써줘야함. print는 system 의 out 클래스에 속해있음

main 함수는 형식을 정해줘야 : main(String args[])


Sublime에서 

빨간색/파란색 : 예약어


class HelloWorld {
예약어 클래스이름 " " 한 칸 띄우고 중괄호 들어가야
	public static void main(String args[]) {
새로운 블럭 시작할 때는 들여쓰기를 꼭 해야! 공백 4개   (or tab-글자 1칸 커스터마이징도 가능)
		System.out.print("Hello World");
두번 들어간 들여쓰기. 

완전한 객체지향 언어는 항상 함수 안에서 로직, 변수 선언이 되어야

클래스 안에서 변수 선언은 가능. 연산은 못함.

로직은 함수 안에서만 가능


로직은 줄이 바뀌게 되면 세미콜론으로 그 줄을 종료

	}

}

로직은 뭔가요?

단순한 선언과 다름. int a=0

연산과 계산이 일어나는 부분 int c=a+b



** 파이썬에서는 공백을 스페이스랑 탭을 혼합해서 주면 컴파일이 안됨

스페이스만 쓰던가, 탭만 쓰던가~




4. 매직넘버 -> 바이너리 파일. 최초 4bit


cafe babe

504b 0304 zip


5. Java 파일의 런타임 컴파일

VM을 통한 컴파일 두가지

JIT : 실행시 최초 한번 클래스 파일을 기계어로 컴파일. 속도 저하. 파일이 호출될 때 실행 !
Just In Time
실행할때만 있고 닫으면 번역한 내용을 저장안함


AOT
Ahead Of Time : 설치 시 최초한번 기계어로 컴파일. 안드로이드처럼 설치가 명확한 구조만 가능

용량을 많이 차지함. 번역된 걸 계속 가지고 있음.

=> 다운로드 받으면 OS가 알아서 둘 중에 하나를 씀

pre compile : javac 클래스 만듬


자바랑 안드로이드가 다른 이유?
자바 실행환경 ART 

 

클래스 로더에 온 코드는 
Method Area - 항상 있어야 되는 내용 
Heap - 지금 실행되는 변수 등등이 저장되는 곳 => 가비지 컬렉터가 확인하고 지우는 곳.
Java steak - 함수 내에 있는 변수들이 들어가는 공간.



new: 공간을 변수보다는 좀 더 크게 주는 것을 의미.. 

생성자
클래스 명을 다시 한 번 써줌 => 다른 클래스의 함수를 여기서 쓰겠다는 의미.



자바는 Pacage 언어..

URL 패키지명을 지정함. 객체명을 구분해주기 위해서.

패키지명이 다른 클래스가 서로 이름이 같으면..

구분하기가 어려워짐. 
패키지명. 클래스명() 변수 = new.패키지명. 클래스명();


====================================================


변수와 상수 구별하기

상수는 한번 정하면 못바꿈~

6. 기본 자료형 - 퍼포먼스. 길이가 지정되어있음

문자형2 string - 가장 많이 씀. 기본형은 아님. => 길이 제한이 없음, " 쌍따옴표 사용.


논리형

문자형 - 범위가 지정되어 있음. 2 byte ' 외따옴표 사용. 유니코드

정수형 : 
바이트 +바이트 = 인트
바이트+쇼트 = 인트
char + char = 인트 + 인트 

실수형
일반적인 소수는 모두 더블로 인식
float
double

소수점 연산오류 원인
컴퓨터는 기본적으로 0.1을 표현할 수 없다
0과 1의 정수만 표현가능한데, 소수점 표현을 위해 지수부와 가수부를 구분해서 표시


>지수가수 표기범

a = 0.1515*10E1
b = 0.55 * 10E-5

>풀어쓰기

a=1.515
b=0.0000055

>지수가수 표기법으로 변경 (가수에 할당된 자리수가 7자리일 경우)
a+b = 0.15150055*10E1 < 1.5150055 (실제 숫자) 
>여기서 0.0000005의 오차가 발생한다.

> 가수부가 3자리로 한정되면 아래와 같이 뒷자리가 절삭된다.
자리가 모자라서 없애버리면서 오차 발생!

a+b = 0.152*10

11. 브랜드별 CPU의 소수점 연산오류 - '거상' 게임


=============================
12. 부동 소수점 연산의 한계

정확한 수치연산을 위해서 소수점이하 값이 있는 값들(부동소수점)끼리 연산을 못하도록 규정하고 있다.

Double 함수에다 int 변수를 계산하면 값을 소수점이하로 내줌

  
13. 자료형 변환(Type Casting)
float 랑 연산하는 int byte long 은 모두 float 로 나옴

14. 자료형 변환

숫자를 문자로 변경

파싱 : 문자를 숫자로 변경

15. 연산 우선순위

16. 산술연산자 

17. ! not 연산자
반대로

18. ~(bit not) 연산자
0과 1을 바꿔줌.
 인티저. 4바이트. 너무 큰 값을 넣으면 마이너스로 값이 바뀜

19. 쉬프트 연산자 1
변수값을 2진 비트로 변경하고 입력한 값만큼 비트를 이동시킨다. 
값을 한번 이동할때  

통째로 한칸씩 옮김 
3칸을 옮겨야 부호가 안바뀜

20 관계연산자

21. 논리연산자
Short-Circuit 
if &&, ||에서 앞의 값이 틀리거나 맞으면 
뒤에거는 계산 안해도 됨

22. 비트논리 연산자

XOR : 둘의 값이 달라야 1

배타적 OR

23. 3항 연산자

boolean pass;
pass = (국어 > 국어)? true:false

24. 증감 연산자

++, -- 가독성때문에 빠지는 추세

a += 3 == a = a+3 

스트링, 인트가 혼합된 값은 string a = null + " " 을 쓸수있음

======================================
/** 지불한 금액 payed에서
실제가격 amount 를 빼고
남은 거스름돈의 개수를 출력하세요.


제약조건
payed  = 10,000원
amount = 3,720원

@param payed
@param amount
public
*/

public void calculate ( int payed, int amount) {

int ft = 0;
//잔돈 중 오천원권의 개수
//계산 후

ft = 1;

System.out.println("오천원:"+ ft +"개"

}


=====================================================


무조건 한 번은 실행시키는 것 do while


break와 continue


//첫글자가 대문자면 클래스